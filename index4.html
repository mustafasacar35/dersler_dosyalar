<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bulgarca √ñƒürenme Uygulamasƒ±</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { 
            background-color: #f8f9fa; 
            padding: 20px; 
            display: flex; 
            flex-direction: column; 
            min-height: 100vh; 
            margin: 0; 
            transition: background-color 0.3s, color 0.3s;
        }
        .top-bar { margin-bottom: 20px; }
        .content-wrapper { display: flex; flex-grow: 1; }
        .sidebar { width: 250px; margin-right: 20px; flex-shrink: 0; }
        .main-content { flex-grow: 1; overflow-y: auto; }
        .card { margin-bottom: 15px; background-color: #fff; transition: background-color 0.3s; }
        .result-icon { font-size: 1.5em; margin-right: 10px; }
        .correct { color: green; }
        .incorrect { color: red; }
        .unanswered { color: black; }
        #score { font-size: 1.2em; font-weight: bold; }
        #recent-questions, #search-results, #blacklist, #missed-questions { 
            margin-top: 20px; 
            max-height: 150px; 
            overflow-y: auto; 
        }
        .recent-question, .search-result, .blacklist-item, .missed-question { 
            cursor: pointer; 
            padding: 5px; 
            border-bottom: 1px solid #ddd; 
        }
        .recent-question:hover, .search-result:hover, .blacklist-item:hover, .missed-question:hover { 
            background-color: #e9ecef; 
        }
        .edit-icon { cursor: pointer; margin-left: 10px; color: #007bff; }
        .edit-icon:hover { color: #0056b3; }
        .blacklist-toggle { margin-right: 10px; }
        .search-active { background-color: #d4edda; }
        .search-container { display: flex; align-items: center; }
        .search-container label { margin-left: 5px; margin-right: 10px; }
        .json-file { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
        .delete-btn { margin-left: 10px; }
        .speaking { color: #28a745; }
        .card-title { font-size: 1.5em; font-weight: bold; }
        #input-answer { width: 70%; font-size: 1.1em; }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        #result.correct { animation: fadeIn 0.5s ease-in; color: green; }
        #result.incorrect { animation: fadeIn 0.5s ease-in; color: red; }
        .dark-theme { background-color: #343a40; color: #f8f9fa; }
        .dark-theme .card { background-color: #495057; }
        .dark-theme .btn-primary { background-color: #007bff; }
        .reference-table { margin-top: 20px; }
        .reference-table table { 
            width: 100%; 
            border-collapse: collapse; 
            font-size: 0.9em; 
        }
        .reference-table th, .reference-table td { 
            border: 1px solid #ddd; 
            padding: 8px; 
            text-align: center; 
        }
        .reference-table th { background-color: #f2f2f2; }
        .highlight { background-color: #ffff99; }
        .correct-highlight { background-color: #ccffcc; }
        .incorrect-highlight { background-color: #ffcccc; }
        @keyframes blinkCorrect {
            0% { background-color: #ccffcc; }
            50% { background-color: #99cc99; }
            100% { background-color: #ccffcc; }
        }
        @keyframes blinkIncorrect {
            0% { background-color: #ffcccc; }
            50% { background-color: #ff9999; }
            100% { background-color: #ffcccc; }
        }
        .blink-correct { animation: blinkCorrect 0.5s ease 3; }
        .blink-incorrect { animation: blinkIncorrect 0.5s ease 3; }
        #question-slider { width: 100%; margin-bottom: 20px; }
        @media (max-width: 768px) {
            .sidebar { width: 100%; margin-right: 0; margin-bottom: 20px; }
            .content-wrapper { flex-direction: column; }
            .btn { font-size: 0.9em; padding: 5px; }
            #input-answer { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="top-bar container">
        <h1 class="text-center mb-4">Bulgarca √ñƒürenme Uygulamasƒ±</h1>
        <input type="range" id="question-slider" min="0" max="0" value="0" class="form-range">
        <div class="progress mb-3">
            <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
        </div>
        <div class="row mb-3">
            <div class="col-md-2">
                <div class="dropdown">
                    <button class="btn btn-primary dropdown-toggle w-100" type="button" data-bs-toggle="dropdown">Se√ßenekler</button>
                    <ul class="dropdown-menu">
                        <li><button class="dropdown-item" data-bs-toggle="modal" data-bs-target="#loadJsonModal">Ders Ekle</button></li>
                        <li><button class="dropdown-item" id="exportJsonBtn">Dersi Dƒ±≈üarƒ± Aktar</button></li>
                        <li><button class="dropdown-item" id="saveToGitHubBtn">GitHub‚Äôa Kaydet</button></li>
                        <li><button class="dropdown-item" id="saveBtn">Kaydet</button></li>
                        <li><button class="dropdown-item" id="loadStateBtn">Durum Y√ºkle</button></li>
                        <li><button class="dropdown-item" id="resetBtn">Reset</button></li>
                        <li><button class="dropdown-item" id="toggleThemeBtn">Koyu Tema</button></li>
                    </ul>
                </div>
            </div>
            <div class="col-md-2"><button id="toggleOrderBtn" class="btn btn-info w-100 mb-2">Sƒ±ralƒ± Mod (≈ûu an: Sƒ±ralƒ±)</button></div>
            <div class="col-md-2"><button id="toggleLangBtn" class="btn btn-warning w-100 mb-2">T√ºrk√ße Sorulara Ge√ß</button></div>
            <div class="col-md-2"><button id="toggleSpeechBtn" class="btn btn-secondary w-100 mb-2">Sesli Okuma (Kapalƒ±)</button></div>
            <div class="col-md-2"><button id="toggleSoundBtn" class="btn btn-secondary w-100 mb-2">Ses Efektleri (Kapalƒ±)</button></div>
            <div class="col-md-2"><button id="reviewMissedBtn" class="btn btn-danger w-100 mb-2">Bilemediklerim Sƒ±navƒ±</button></div>
        </div>
        <div class="modal fade" id="loadJsonModal" tabindex="-1" aria-labelledby="loadJsonModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="loadJsonModalLabel">Ders Ekle</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label for="fileUrl" class="form-label">GitHub Raw URL‚Äôsi:</label>
                            <input type="text" class="form-control" id="fileUrl" placeholder="√ñrn: https://raw.githubusercontent.com/.../DERS_6.JSON">
                        </div>
                        <div class="mb-3">
                            <label for="localJsonFile" class="form-label">Yerel JSON Dosyasƒ±:</label>
                            <input type="file" class="form-control" id="localJsonFile" accept=".json">
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Kapat</button>
                        <button type="button" class="btn btn-primary" id="loadFromUrlBtn">URL‚Äôden Ekle</button>
                        <button type="button" class="btn btn-primary" id="loadFromLocalBtn">Yerelden Ekle</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="row mb-3">
            <div class="col-md-2"><button id="toggleRepeatWrongBtn" class="btn btn-secondary w-100 mb-2">Yanlƒ±≈ülarƒ± Tekrarla (A√ßƒ±k)</button></div>
            <div class="col-md-10">
                <div class="search-container">
                    <input type="checkbox" id="focus-questions" />
                    <label for="focus-questions">Odak Sorular</label>
                    <input type="text" class="form-control" id="search-input" placeholder="Sorularda ara...">
                    <div class="form-check ms-3">
                        <input class="form-check-input" type="checkbox" id="autoNextToggle" checked>
                        <label class="form-check-label" for="autoNextToggle">Otomatik ƒ∞lerle</label>
                    </div>
                </div>
            </div>
        </div>
        <div id="score" class="text-center mb-3">Puan: 0</div>
    </div>
    <div class="content-wrapper container">
        <div class="sidebar card">
            <div class="card-body">
                <h6>Y√ºklenen Dersler</h6>
                <div id="json-files"></div>
            </div>
        </div>
        <div class="main-content">
            <div id="content" class="card"></div>
            <div id="recent-questions" class="card"><div class="card-body"><h6>Son 5 Soru:</h6><div id="recent-list"></div></div></div>
            <div id="search-results" class="card"><div class="card-body"><h6>Arama Sonu√ßlarƒ±:</h6><div id="search-list"></div></div></div>
            <div id="blacklist" class="card"><div class="card-body"><h6>Karalisteye Alƒ±nanlar:</h6><div id="blacklist-list"></div></div></div>
            <div id="missed-questions" class="card"><div class="card-body"><h6>Bilemediƒüim Sorular:</h6><div id="missed-list"></div></div></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.min.js"></script>
    <script>
        let lessonData = [];
        let jsonFiles = {};
        let currentIndex = 0;
        let score = 0;
        let answers = [];
        let recentQuestions = [];
        let blacklist = [];
        let wrongCount = {};
        let priorityQueue = [];
        let missedQuestions = [];
        let questionCounter = 0;
        let isRandomOrder = false;
        let isTurkishQuestion = false;
        let lastIndexBeforeJump = -1;
        let autoNextTimeout = null;
        let isAutoNextPaused = false;
        let lastSequentialIndex = 0;
        let searchResults = [];
        let searchIndex = 0;
        let isSearchMode = false;
        let isResultShown = false;
        let isSpeechEnabled = false;
        let isLatinVisible = false;
        let isRepeatWrongEnabled = true;
        let isSoundEnabled = false;
        let isMissedMode = false;

        const githubLessonUrls = [
            { name: "Ders 1", url: "https://raw.githubusercontent.com/mustafasacar35/dersler_dosyalar/main/DERS_1.JSON" },
            { name: "Ders 2", url: "https://raw.githubusercontent.com/mustafasacar35/dersler_dosyalar/main/DERS_2.JSON" },
            { name: "Ders 3", url: "https://raw.githubusercontent.com/mustafasacar35/dersler_dosyalar/main/DERS_3.JSON" },
            { name: "Ders 4", url: "https://raw.githubusercontent.com/mustafasacar35/dersler_dosyalar/main/DERS_4.JSON" },
            { name: "Ders 5", url: "https://raw.githubusercontent.com/mustafasacar35/dersler_dosyalar/main/DERS_5.JSON" },
            { name: "Ders 6", url: "https://raw.githubusercontent.com/mustafasacar35/dersler_dosyalar/main/DERS_6.JSON" },
            { name: "Ders 7", url: "https://raw.githubusercontent.com/mustafasacar35/dersler_dosyalar/main/DERS_7.JSON" },
        ];

        async function loadAllLessons() {
            for (const lesson of githubLessonUrls) {
                try {
                    const response = await fetch(lesson.url);
                    if (!response.ok) throw new Error(`Ders y√ºklenemedi: ${lesson.name} - ${response.status}`);
                    const data = await response.json();
                    jsonFiles[lesson.name] = { data: data, selected: lesson.name === "Ders 1" };
                } catch (error) {
                    console.error(`Hata: ${lesson.name} y√ºklenemedi - ${error.message}`);
                }
            }
            updateLessonData();
            updateJsonFilesList();
            renderContent();
            updateSlider();
        }

        const cyrillicToLatin = {
            "–ê": "A", "–ë": "B", "–í": "V", "–ì": "G", "–î": "D", "–ï": "E", "–ñ": "ZH",
            "–ó": "Z", "–ò": "I", "–ô": "Y", "–ö": "K", "–õ": "L", "–ú": "M", "–ù": "N",
            "–û": "O", "–ü": "P", "–†": "R", "–°": "S", "–¢": "T", "–£": "U", "–§": "F",
            "–•": "H", "–¶": "TS", "–ß": "CH", "–®": "SH", "–©": "SHT", "–™": "A", "–¨": "",
            "–Æ": "YU", "–Ø": "YA", "–ç": "I"
        };

        const possessivePronouns = {
            "benim": ["–ú–û–Ø–¢ (moyat)", "–ú–û–Ø–¢–ê (moyata)", "–ú–û–ï–¢–û (moeto)", "–ú–û–ò–¢–ï (moite)"],
            "senin": ["–¢–í–û–Ø–¢ (tvoyat)", "–¢–í–û–Ø–¢–ê (tvoyata)", "–¢–í–û–ï–¢–û (tvoeto)", "–¢–í–û–ò–¢–ï (tvoite)"],
            "onun_erkek": ["–ù–ï–ì–û–í–ò–Ø–¢ (negoviyat)", "–ù–ï–ì–û–í–ê–¢–ê (negovata)", "–ù–ï–ì–û–í–û–¢–û (negovoto)", "–ù–ï–ì–û–í–ò–¢–ï (negovite)"],
            "onun_kadƒ±n": ["–ù–ï–ô–ù–ò–Ø–¢ (neyniyat)", "–ù–ï–ô–ù–ê–¢–ê (neynata)", "–ù–ï–ô–ù–û–¢–û (neynoto)", "–ù–ï–ô–ù–ò–¢–ï (neynite)"],
            "bizim": ["–ù–ê–®–ò–Ø–¢ (na≈üiyat)", "–ù–ê–®–ê–¢–ê (na≈üata)", "–ù–ê–®–ï–¢–û (na≈üeto)", "–ù–ê–®–ò–¢–ï (na≈üite)"],
            "sizin": ["–í–ê–®–ò–Ø–¢ (va≈üiyat)", "–í–ê–®–ê–¢–ê (va≈üata)", "–í–ê–®–ï–¢–û (va≈üeto)", "–í–ê–®–ò–¢–ï (va≈üite)"],
            "onlarƒ±n": ["–¢–ï–•–ù–ò–Ø–¢ (tehniyat)", "–¢–Ø–•–ù–ê–¢–ê (tyahnata)", "–¢–Ø–•–ù–û–¢–û (tyahnoto)", "–¢–ï–•–ù–ò–¢–ï (tehnite)"]
        };

        const shortPossessivePronouns = {
            "benim": "–ú–ò (mi)",
            "senin": "–¢–ò (ti)",
            "onun_erkek": "–ú–£ (mu)",
            "onun_kadƒ±n": "–ò (i)",
            "bizim": "–ù–ò (ni)",
            "sizin": "–í–ò (vi)",
            "onlarƒ±n": "–ò–ú (im)"
        };

        const demonstrativePronouns = {
            "bu": ["–¢–û–ó–ò (TOZƒ∞)", "–¢–ê–ó–ò (TAZƒ∞)", "–¢–û–í–ê (TOVA)", "–¢–ï–ó–ò (TEZƒ∞)"],
            "≈üu_o": ["–û–ù–ó–ò (ONZƒ∞)", "–û–ù–ê–ó–ò (ONAZƒ∞)", "–û–ù–û–í–ê (ONOVA)", "–û–ù–ï–ó–ò (ONEZƒ∞)"]
        };

        const prepositions = [
            ["–í (V)", "ƒ∞√ßinde, -de, -da", "–ö–ù–ò–ì–ê–¢–ê –ï –í –ß–ê–ù–¢–ê–¢–ê", "Kitap √ßantanƒ±n i√ßinde"],
            ["–ó–∞ (Za)", "ƒ∞√ßin", "–¢–û–í–ê –ï –ß–ê–ù–¢–ê –ó–ê –ö–ù–ò–ì–ò", "Bu √ßanta kitap i√ßin"],
            ["–° (S)", "ƒ∞le, birlikte", "–¢–û–ô –ò–î–í–ê –° –ö–û–õ–ê", "O, araba ile geliyor"],
            ["–î–û (Do)", "Yanƒ±nda; -e kadar", "–†–ê–ë–û–¢–ò –î–û 5 –ß–ê–°–ê", "Saat 5‚Äôe kadar √ßalƒ±≈üƒ±yor"],
            ["–°–õ–ï–î (Sled)", "Sonra", "–©–ï –î–û–ô–î–ê –°–õ–ï–î –í–ï–ß–ï–†–Ø", "Yemekten sonra geleceƒüim"],
            ["–û–¢ (Ot)", "-den, -dan", "–ò–î–í–ê –û–¢ –£–ß–ò–õ–ò–©–ï", "Okuldan geliyor"],
            ["–ù–ê (Na)", "-nƒ±n/-nin, -e/-a √ºzerinde", "–ö–ù–ò–ì–ê–¢–ê –ï –ù–ê –ú–ê–°–ê–¢–ê", "Kitap masanƒ±n √ºzerinde"]
        ];

        const questionParticles = {
            "li": "–õ–ò (li) - Soru eki, c√ºmleyi soru haline getirir"
        };

        function cyrillicToLatinText(text) {
            return text.split('').map(char => cyrillicToLatin[char] || char).join('').toUpperCase();
        }

        function normalizeText(text) {
            return text
                .toLowerCase()
                .normalize('NFKD')
                .replace(/[\u0300-\u036f]/g, '')
                .replace(/[ƒ±ƒ∞]/g, 'i')
                .replace(/[iI]/g, 'i')
                .replace(/sh/g, '≈ü')
                .replace(/zh/g, 'j')
                .replace(/ch/g, '√ß')
                .replace(/sht/g, '≈üt')
                .replace(/—ä/g, 'ƒ±')
                .replace(/[^\w\s]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
        }

        function isCyrillic(text) {
            return /[–ê-–Ø–Å–™–¨]/i.test(text.charAt(0));
        }

        function cleanTextForSpeech(text) {
            return text.replace(/\s*\(.*?\)\s*/g, ' ').trim();
        }

        function cleanTextForDisplay(text) {
            if (!isLatinVisible) {
                return text.replace(/\s*\(.*?\)\s*/g, '').trim();
            }
            return text;
        }

        function playSound(type) {
    if (!isSoundEnabled) return;
    const audio = new Audio(type === 'correct' 
        ? 'https://www.myinstants.com/media/sounds/correct-ding.mp3' // Doƒüru i√ßin ho≈ü bir "ding" sesi
        : 'https://www.myinstants.com/media/sounds/wrong-buzzer.mp3' // Yanlƒ±≈ü i√ßin yumu≈üak bir "buzzer" sesi
    );
    audio.play();
}

        function speakText(text) {
            if (isSpeechEnabled && 'speechSynthesis' in window) {
                const cleanText = cleanTextForSpeech(text);
                const utterance = new SpeechSynthesisUtterance(cleanText);
                const isBulgarian = isCyrillic(cleanText);
                utterance.lang = isBulgarian ? 'bg-BG' : 'tr-TR';
                utterance.rate = 0.9;
                utterance.pitch = 1.0;

                const availableVoices = speechSynthesis.getVoices();
                const hasBulgarianVoice = availableVoices.some(voice => voice.lang === 'bg-BG');
                if (isBulgarian && !hasBulgarianVoice) {
                    utterance.text = cyrillicToLatinText(cleanText);
                    utterance.lang = 'tr-TR';
                }

                speechSynthesis.cancel();
                speechSynthesis.speak(utterance);

                const title = document.querySelector('.card-title');
                if (title) title.classList.add('speaking');
                utterance.onend = () => { if (title) title.classList.remove('speaking'); };
            }
        }

        window.addEventListener('load', () => {
            speechSynthesis.getVoices();
            loadAllLessons();
        });

        function levenshteinDistance(a, b) {
            const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
            for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
            for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
            for (let j = 1; j <= b.length; j++) {
                for (let i = 1; i <= a.length; i++) {
                    const indicator = a[i - 1] === b[j - 1] ? 0 : 1;
                    matrix[j][i] = Math.min(
                        matrix[j][i - 1] + 1,
                        matrix[j - 1][i] + 1,
                        matrix[j - 1][i - 1] + indicator
                    );
                }
            }
            return matrix[b.length][a.length];
        }

        function isAnswerCloseEnough(input, correct) {
            const inputWords = normalizeText(input).split(/\s+/);
            const correctWords = normalizeText(correct).split(/\s+/);
            if (Math.abs(inputWords.length - correctWords.length) > 1) return false;
            return inputWords.every((word, i) => {
                if (i >= correctWords.length) return true;
                return levenshteinDistance(word, correctWords[i]) <= 1;
            }) && correctWords.every((word, i) => {
                if (i >= inputWords.length) return true;
                return levenshteinDistance(word, inputWords[i]) <= 1;
            });
        }

        function getActiveQuestionCount() {
            return isMissedMode ? missedQuestions.length : isSearchMode ? searchResults.length : lessonData.length - blacklist.length;
        }

        function getTotalQuestionCount() {
            return Object.values(jsonFiles).reduce((sum, file) => sum + file.data.length, 0);
        }

        function extractParentheticalWords(question) {
            const match = question.match(/\((.*?)\)/);
            if (!match) return [];
            return match[1].split(' - ')[0].trim().split(/\s+/);
        }

        function extractBaseAnswer(answer) {
            const match = answer.match(/^(.*?)\s*\((.*?)\)$/);
            return match ? [match[1].trim(), answer] : [answer, answer];
        }

        function generateCombinations(words, baseAnswer) {
            const results = [baseAnswer];
            const combos = [];
            for (let i = 1; i < (1 << words.length); i++) {
                const combo = [];
                for (let j = 0; j < words.length; j++) {
                    if (i & (1 << j)) combo.push(words[j]);
                }
                combos.push(combo);
            }
            combos.forEach(combo => {
                const permutations = getPermutations(combo);
                permutations.forEach(perm => {
                    results.push(`${perm.join(' ')} ${baseAnswer}`);
                });
            });
            return results;
        }

        function getPermutations(arr) {
            if (arr.length === 0) return [[]];
            const result = [];
            for (let i = 0; i < arr.length; i++) {
                const rest = arr.slice(0, i).concat(arr.slice(i + 1));
                const subPerms = getPermutations(rest);
                subPerms.forEach(subPerm => {
                    result.push([arr[i]].concat(subPerm));
                });
            }
            return result;
        }

        function saveState() {
            const state = {
                currentIndex, score, answers, recentQuestions, blacklist, wrongCount, priorityQueue,
                missedQuestions, questionCounter, isRandomOrder, isTurkishQuestion, lastSequentialIndex,
                searchResults, searchIndex, isSearchMode, isSpeechEnabled, isLatinVisible, isRepeatWrongEnabled,
                isSoundEnabled, jsonFiles, isMissedMode
            };
            const defaultName = 'bulgarca_app_state.json';
            const fileName = prompt("Durumu kaydetmek i√ßin bir dosya adƒ± girin:", defaultName) || defaultName;
            const jsonStr = JSON.stringify(state, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName.endsWith('.json') ? fileName : `${fileName}.json`;
            a.click();
            URL.revokeObjectURL(url);
            localStorage.setItem('bulgarcaAppState', jsonStr);
            alert(`Durum '${a.download}' olarak kaydedildi!`);
        }

        function loadSavedState() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const state = JSON.parse(event.target.result);
                        applyState(state);
                        localStorage.setItem('bulgarcaAppState', JSON.stringify(state));
                        alert(`Durum '${file.name}' dosyasƒ±ndan y√ºklendi!`);
                    } catch (error) {
                        alert('Ge√ßersiz durum dosyasƒ±: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function applyState(state) {
            currentIndex = state.currentIndex || 0;
            score = state.score || 0;
            answers = state.answers || [];
            recentQuestions = state.recentQuestions || [];
            blacklist = state.blacklist || [];
            wrongCount = state.wrongCount || {};
            priorityQueue = state.priorityQueue || [];
            missedQuestions = state.missedQuestions || [];
            questionCounter = state.questionCounter || 0;
            isRandomOrder = state.isRandomOrder || false;
            isTurkishQuestion = state.isTurkishQuestion || false;
            lastSequentialIndex = state.lastSequentialIndex || 0;
            searchResults = state.searchResults || [];
            searchIndex = state.searchIndex || 0;
            isSearchMode = state.isSearchMode || false;
            isSpeechEnabled = state.isSpeechEnabled || false;
            isLatinVisible = state.isLatinVisible || false;
            isRepeatWrongEnabled = state.isRepeatWrongEnabled !== undefined ? state.isRepeatWrongEnabled : true;
            isSoundEnabled = state.isSoundEnabled || false;
            jsonFiles = state.jsonFiles || {};
            isMissedMode = state.isMissedMode || false;
            lessonData = [];
            Object.entries(jsonFiles).forEach(([name, file]) => {
                if (file.selected) lessonData = lessonData.concat(file.data);
            });
            updateUIFromState();
            renderContent();
            updateSlider();
        }

        function updateUIFromState() {
            document.getElementById('toggleOrderBtn').innerText = `Sƒ±ralƒ± Mod (≈ûu an: ${isRandomOrder ? 'Rastgele' : 'Sƒ±ralƒ±'})`;
            document.getElementById('toggleLangBtn').innerText = isTurkishQuestion ? 'Bulgarca Sorulara Ge√ß' : 'T√ºrk√ße Sorulara Ge√ß';
            document.getElementById('toggleSpeechBtn').innerText = `Sesli Okuma (${isSpeechEnabled ? 'A√ßƒ±k' : 'Kapalƒ±'})`;
            document.getElementById('toggleSoundBtn').innerText = `Ses Efektleri (${isSoundEnabled ? 'A√ßƒ±k' : 'Kapalƒ±'})`;
            document.getElementById('toggleRepeatWrongBtn').innerText = `Yanlƒ±≈ülarƒ± Tekrarla (${isRepeatWrongEnabled ? 'A√ßƒ±k' : 'Kapalƒ±'})`;
            document.getElementById('toggleThemeBtn').innerText = document.body.classList.contains('dark-theme') ? 'A√ßƒ±k Tema' : 'Koyu Tema';
            document.getElementById('score').innerText = `Puan: ${score}`;
            updateJsonFilesList();
            updateProgressBar();
            updateMissedQuestions();
        }

        function resetState() {
            localStorage.removeItem('bulgarcaAppState');
            currentIndex = 0;
            score = 0;
            answers = [];
            recentQuestions = [];
            blacklist = [];
            wrongCount = {};
            priorityQueue = [];
            missedQuestions = [];
            questionCounter = 0;
            isRandomOrder = false;
            isTurkishQuestion = false;
            lastIndexBeforeJump = -1;
            lastSequentialIndex = 0;
            searchResults = [];
            searchIndex = 0;
            isSearchMode = false;
            isSpeechEnabled = false;
            isLatinVisible = false;
            isRepeatWrongEnabled = true;
            isSoundEnabled = false;
            isMissedMode = false;
            jsonFiles = {};
            lessonData = [];
            loadAllLessons();
            updateUIFromState();
            renderContent();
            alert("Durum sƒ±fƒ±rlandƒ±!");
        }

        function saveToGitHub() {
            Object.entries(jsonFiles).forEach(([name, file]) => {
                const jsonStr = JSON.stringify(file.data, null, 2);
                const blob = new Blob([jsonStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${name}.json`;
                a.click();
                URL.revokeObjectURL(url);
            });
            alert("T√ºm ders dosyalarƒ± yerel olarak indirildi. L√ºtfen bu dosyalarƒ± GitHub‚Äôa manuel olarak y√ºkleyin!");
        }

        function updateLessonData() {
            lessonData = [];
            Object.entries(jsonFiles).forEach(([name, file]) => {
                if (file.selected) {
                    lessonData = lessonData.concat(file.data);
                }
            });
            currentIndex = lessonData.length > 0 ? Math.min(currentIndex, lessonData.length - 1) : 0;
            answers = Array(lessonData.length).fill(null);
            recentQuestions = [];
            blacklist = [];
            wrongCount = {};
            priorityQueue = [];
            missedQuestions = [];
            renderContent();
            updateSlider();
        }

        function updateProgressBar() {
            const progress = getActiveQuestionCount() > 0 ? ((currentIndex + 1) / getActiveQuestionCount()) * 100 : 0;
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = `${progress}%`;
            progressBar.setAttribute('aria-valuenow', progress);
        }

        function updateSlider() {
            const slider = document.getElementById('question-slider');
            slider.max = getActiveQuestionCount() - 1;
            slider.value = isMissedMode ? missedQuestions.indexOf(currentIndex) : isSearchMode ? searchIndex : currentIndex;
        }

        function renderPossessiveTable(matchedWord) {
            let tableHTML = `
                <div class="reference-table possessive-table">
                    <h6>TAM ƒ∞YELƒ∞K ZAMƒ∞RLERƒ∞:</h6>
                    <p>Tam iyelik zamirleri, isimden √∂nce ya da vurgu gerektiƒüinde kullanƒ±lƒ±r.</p>
                    <table>
                        <thead>
                            <tr>
                                <th></th>
                                <th>Eril</th>
                                <th>Di≈üil</th>
                                <th>N√∂tr</th>
                                <th>√áoƒüul</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            const rows = [
                ["Benim", possessivePronouns["benim"]],
                ["Senin", possessivePronouns["senin"]],
                ["Onun (erkek)", possessivePronouns["onun_erkek"]],
                ["Onun (kadƒ±n)", possessivePronouns["onun_kadƒ±n"]],
                ["Bizim", possessivePronouns["bizim"]],
                ["Sizin", possessivePronouns["sizin"]],
                ["Onlarƒ±n", possessivePronouns["onlarƒ±n"]]
            ];
            rows.forEach(([label, pronouns]) => {
                tableHTML += `<tr><td>${label}</td>`;
                pronouns.forEach(pronoun => {
                    const word = pronoun.split(' ')[0];
                    const isHighlighted = matchedWord && word === matchedWord;
                    tableHTML += `<td class="${isHighlighted ? 'highlight' : ''}" data-word="${word}">${pronoun}</td>`;
                });
                tableHTML += `</tr>`;
            });
            tableHTML += `</tbody></table></div>`;
            return tableHTML;
        }

        function renderShortPossessiveTable(matchedWord) {
            let tableHTML = `
                <div class="reference-table short-possessive-table">
                    <h6>KISA ƒ∞YELƒ∞K ZAMƒ∞RLERƒ∞:</h6>
                    <p>Kƒ±sa iyelik zamirleri g√ºnl√ºk konu≈ümalarda √ßok sƒ±k kullanƒ±lƒ±r ve Bulgarca ileti≈üimde temel bir rol oynar.</p>
                    <table>
                        <thead>
                            <tr>
                                <th>T√ºrk√ße</th>
                                <th>Bulgarca</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            const rows = [
                ["Benim", shortPossessivePronouns["benim"]],
                ["Senin", shortPossessivePronouns["senin"]],
                ["Onun (erkek)", shortPossessivePronouns["onun_erkek"]],
                ["Onun (kadƒ±n)", shortPossessivePronouns["onun_kadƒ±n"]],
                ["Bizim", shortPossessivePronouns["bizim"]],
                ["Sizin", shortPossessivePronouns["sizin"]],
                ["Onlarƒ±n", shortPossessivePronouns["onlarƒ±n"]]
            ];
            rows.forEach(([turkish, bulgarian]) => {
                const word = bulgarian.split(' ')[0];
                const isHighlighted = matchedWord && word === matchedWord;
                tableHTML += `<tr><td>${turkish}</td><td class="${isHighlighted ? 'highlight' : ''}" data-word="${word}">${bulgarian}</td></tr>`;
            });
            tableHTML += `</tbody></table></div>`;
            return tableHTML;
        }

        function renderDemonstrativeTable(matchedWord) {
            let tableHTML = `
                <div class="reference-table demonstrative-table">
                    <h6>YAKIN NESNELER (BU) - UZAK NESNELER (≈ûU/O):</h6>
                    <p>G√∂sterim zamirleri, nesnelerin yakƒ±nlƒ±k veya uzaklƒ±ƒüƒ±nƒ± belirtmek i√ßin kullanƒ±lƒ±r.</p>
                    <table>
                        <thead>
                            <tr>
                                <th>T√ºr</th>
                                <th>Eril</th>
                                <th>Di≈üil</th>
                                <th>N√∂tr</th>
                                <th>√áoƒüul</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            const rows = [
                ["BU", demonstrativePronouns["bu"]],
                ["≈ûU/O", demonstrativePronouns["≈üu_o"]]
            ];
            rows.forEach(([label, pronouns]) => {
                tableHTML += `<tr><td>${label}</td>`;
                pronouns.forEach(pronoun => {
                    const word = pronoun.split(' ')[0];
                    const isHighlighted = matchedWord && word === matchedWord;
                    tableHTML += `<td class="${isHighlighted ? 'highlight' : ''}" data-word="${word}">${pronoun}</td>`;
                });
                tableHTML += `</tr>`;
            });
            tableHTML += `</tbody></table></div>`;
            return tableHTML;
        }

        function renderPrepositionTable(matchedWord) {
            let tableHTML = `
                <div class="reference-table preposition-table">
                    <h6>BULGARCADA EDATLAR:</h6>
                    <p>Bulgarcada edatlar c√ºmlede nesneler, ki≈üiler ve olaylar arasƒ±ndaki ili≈ükileri ifade etmek i√ßin kullanƒ±lƒ±r.</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Edat</th>
                                <th>T√ºrk√ße Anlamƒ±</th>
                                <th>√ñrnek C√ºmle</th>
                                <th>Anlamƒ±</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            prepositions.forEach(row => {
                tableHTML += `<tr>`;
                row.forEach((cell, index) => {
                    const word = index === 0 ? cell.split(' ')[0] : '';
                    const isHighlighted = matchedWord && index === 0 && word === matchedWord;
                    tableHTML += `<td class="${isHighlighted ? 'highlight' : ''}" data-word="${word}">${cell}</td>`;
                });
                tableHTML += `</tr>`;
            });
            tableHTML += `</tbody></table></div>`;
            return tableHTML;
        }

        function renderQuestionParticlesTable(matchedWord) {
            let tableHTML = `
                <div class="reference-table question-particles-table">
                    <h6>SORU EKLERƒ∞:</h6>
                    <p>Soru ekleri, Bulgarca'da c√ºmleleri soru haline getirmek i√ßin kullanƒ±lƒ±r.</p>
                    <table>
                        <thead>
                            <tr>
                                <th>Bulgarca</th>
                                <th>A√ßƒ±klama</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            const rows = [
                ["–õ–ò (li)", "Soru eki, c√ºmleyi soru haline getirir"]
            ];
            rows.forEach(([bulgarian, description]) => {
                const word = bulgarian.split(' ')[0];
                const isHighlighted = matchedWord && word === matchedWord;
                tableHTML += `<tr><td class="${isHighlighted ? 'highlight' : ''}" data-word="${word}">${bulgarian}</td><td>${description}</td></tr>`;
            });
            tableHTML += `</tbody></table></div>`;
            return tableHTML;
        }

        function getReferenceTables(text) {
            const words = text.split(/\s+/);
            const allPossessives = Object.values(possessivePronouns).flat().map(p => p.split(' ')[0]);
            const allShortPossessives = Object.values(shortPossessivePronouns).map(p => p.split(' ')[0]);
            const allDemonstratives = Object.values(demonstrativePronouns).flat().map(p => p.split(' ')[0]);
            const allPrepositions = prepositions.map(p => p[0].split(' ')[0]);
            const allQuestionParticles = Object.values(questionParticles).map(p => p.split(' ')[0]);

            const matchedPossessive = words.find(word => allPossessives.includes(word));
            const matchedShortPossessive = words.find(word => allShortPossessives.includes(word));
            const matchedDemonstrative = words.find(word => allDemonstratives.includes(word));
            const matchedPreposition = words.find(word => allPrepositions.includes(word));
            const matchedQuestionParticle = words.find(word => allQuestionParticles.includes(word));

            let tables = '';
            const tableOrder = [];

            if (matchedPossessive) tableOrder.push({ type: 'possessive', word: matchedPossessive, index: text.indexOf(matchedPossessive) });
            if (matchedShortPossessive) tableOrder.push({ type: 'shortPossessive', word: matchedShortPossessive, index: text.indexOf(matchedShortPossessive) });
            if (matchedDemonstrative) tableOrder.push({ type: 'demonstrative', word: matchedDemonstrative, index: text.indexOf(matchedDemonstrative) });
            if (matchedPreposition) tableOrder.push({ type: 'preposition', word: matchedPreposition, index: text.indexOf(matchedPreposition) });
            if (matchedQuestionParticle) tableOrder.push({ type: 'questionParticle', word: matchedQuestionParticle, index: text.indexOf(matchedQuestionParticle) });

            tableOrder.sort((a, b) => a.index - b.index);

            tableOrder.forEach(item => {
                if (item.type === 'possessive') tables += renderPossessiveTable(item.word);
                else if (item.type === 'shortPossessive') tables += renderShortPossessiveTable(item.word);
                else if (item.type === 'demonstrative') tables += renderDemonstrativeTable(item.word);
                else if (item.type === 'preposition') tables += renderPrepositionTable(item.word);
                else if (item.type === 'questionParticle') tables += renderQuestionParticlesTable(item.word);
            });

            return tables;
        }

        function updateTableFeedback(isCorrect, matchedWords) {
            const tables = document.querySelectorAll('.reference-table');
            tables.forEach(table => {
                const cells = table.querySelectorAll('td[data-word]');
                cells.forEach(cell => {
                    const word = cell.getAttribute('data-word');
                    if (matchedWords.includes(word)) {
                        cell.classList.remove('highlight', 'correct-highlight', 'incorrect-highlight');
                        if (isCorrect) {
                            cell.classList.add('blink-correct');
                            cell.classList.add('correct-highlight');
                            cell.innerHTML = `‚úÖ ${cell.innerHTML.replace(/^‚úÖ\s*|^‚ùå\s*/, '')}`;
                        } else {
                            cell.classList.add('blink-incorrect');
                            cell.classList.add('incorrect-highlight');
                            cell.innerHTML = `‚ùå ${cell.innerHTML.replace(/^‚úÖ\s*|^‚ùå\s*/, '')}`;
                        }
                        setTimeout(() => {
                            cell.classList.remove('blink-correct', 'blink-incorrect');
                        }, 1500);
                    }
                });
            });
        }

        async function loadOnlineLesson(fileUrl, fileName = 'GitHubLesson.json') {
            try {
                const response = await fetch(fileUrl);
                if (!response.ok) throw new Error('Aƒü yanƒ±tƒ± ba≈üarƒ±sƒ±z: ' + response.status);
                const newData = await response.json();
                jsonFiles[fileName] = { data: newData, selected: true };
                updateLessonData();
                updateJsonFilesList();
                score = 0;
                document.getElementById('score').innerText = `Puan: 0`;
                alert(`${fileName} ba≈üarƒ±yla y√ºklendi!`);
            } catch (error) {
                alert('GitHub‚Äôdan ders y√ºklenemedi: ' + error.message);
            }
        }

        function renderContent() {
            const contentDiv = document.getElementById('content');
            if (!contentDiv) return;

            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.forEach(tooltipTriggerEl => {
                const tooltip = bootstrap.Tooltip.getInstance(tooltipTriggerEl);
                if (tooltip) tooltip.dispose();
            });

            if (!lessonData || lessonData.length === 0) {
                contentDiv.innerHTML = '<div class="card-body"><p>L√ºtfen bir ders ekleyin.</p></div>';
                return;
            }

            if (currentIndex < 0 || currentIndex >= lessonData.length) {
                currentIndex = 0;
            }

            const item = lessonData[currentIndex];
            if (!item || !item.question || !item.answer) {
                contentDiv.innerHTML = '<div class="card-body"><p>Ge√ßersiz veri formatƒ±: Soru veya cevap eksik.</p></div>';
                return;
            }

            let question = isTurkishQuestion ? item.answer : (Array.isArray(item.question) ? item.question[0] : item.question);
            question = cleanTextForDisplay(question);
            const tooltipAnswer = isTurkishQuestion 
                ? (Array.isArray(item.question) ? item.question.map(q => `${q} - ${cyrillicToLatinText(q)}`).join(' / ') : `${item.question} - ${cyrillicToLatinText(item.question)}`)
                : item.answer;

            const referenceTables = getReferenceTables(question + ' ' + tooltipAnswer);

            contentDiv.innerHTML = `
                <div class="card-body ${isSearchMode ? 'search-active' : ''} ${isMissedMode ? 'missed-active' : ''}">
                    <h5 class="card-title" data-bs-toggle="tooltip" data-bs-placement="top" title="${tooltipAnswer}">${question} <span class="edit-icon" onclick="editQuestion()">‚úèÔ∏è</span> <span class="edit-icon" onclick="toggleBlacklist(${currentIndex})">${blacklist.includes(currentIndex) ? '‚úñ' : 'üö´'}</span></h5>
                    <div class="input-group mb-3">
                        <input type="text" class="form-control" id="input-answer" placeholder="Cevabƒ±nƒ±zƒ± buraya yazƒ±n" value="${answers[currentIndex] || ''}">
                        <button class="btn btn-outline-primary" onclick="checkAnswer()">Kontrol Et</button>
                        <button id="prevBtn" class="btn btn-secondary me-2" ${isMissedMode ? (missedQuestions.indexOf(currentIndex) === 0) : isSearchMode ? (searchIndex === 0) : (currentIndex === 0) ? 'disabled' : ''}>Geri</button>
                        <button id="nextBtn" class="btn btn-secondary" ${isMissedMode ? (missedQuestions.indexOf(currentIndex) === missedQuestions.length - 1) : currentIndex === lessonData.length - 1 || blacklist.includes(currentIndex) ? 'disabled' : ''}>ƒ∞leri</button>
                        <button class="btn btn-outline-warning" id="editBtn" onclick="enableEdit()" ${answers[currentIndex] ? '' : 'disabled'}>D√ºzenle</button>
                    </div>
                    <div id="result"></div>
                    <p>Soru: ${isMissedMode ? missedQuestions.indexOf(currentIndex) + 1 : isSearchMode ? searchIndex + 1 : currentIndex + 1}/${getActiveQuestionCount()} (${getTotalQuestionCount()}) ${isMissedMode ? '(Bilemediklerim Modu)' : isSearchMode ? '(Arama Modu)' : ''}</p>
                    ${referenceTables}
                </div>
            `;
            updateRecentQuestions();
            updateBlacklist();
            updateMissedQuestions();
            updateProgressBar();
            updateSlider();

            const newTooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            newTooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });

            const input = document.getElementById('input-answer');
            if (input) {
                input.focus();
                input.addEventListener('keypress', function(event) {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        if (!isResultShown) {
                            checkAnswer();
                        } else {
                            if (autoNextTimeout) clearTimeout(autoNextTimeout);
                            moveToNextQuestion();
                            renderContent();
                        }
                    }
                });
            }

            if (!isResultShown) {
                contentDiv.addEventListener('click', function() {
                    isAutoNextPaused = true;
                    if (autoNextTimeout) {
                        clearTimeout(autoNextTimeout);
                        autoNextTimeout = null;
                    }
                }, { once: true });
            }

            if (answers[currentIndex] && !isAutoNextPaused) {
                checkAnswer(true);
            }

            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            if (prevBtn) {
                prevBtn.addEventListener('click', () => {
                    if (isMissedMode) {
                        const currentMissedIdx = missedQuestions.indexOf(currentIndex);
                        if (currentMissedIdx > 0) {
                            currentIndex = missedQuestions[currentMissedIdx - 1];
                            renderContent();
                        }
                    } else if (isSearchMode) {
                        if (searchIndex > 0) {
                            searchIndex--;
                            currentIndex = searchResults[searchIndex];
                            renderContent();
                        }
                    } else if (currentIndex > 0) {
                        do {
                            currentIndex--;
                        } while (blacklist.includes(currentIndex) && currentIndex > 0);
                        renderContent();
                    }
                });
            }
            if (nextBtn) {
                nextBtn.addEventListener('click', () => {
                    moveToNextQuestion();
                    renderContent();
                });
            }

            if (autoNextTimeout) {
                clearTimeout(autoNextTimeout);
                autoNextTimeout = null;
            }
            isResultShown = false;

            if (isSpeechEnabled) {
                speakText(question);
            }
        }

        function checkAnswer(isReload = false) {
            const input = document.getElementById('input-answer');
            if (!input) return;
            const inputValue = input.value.trim();
            const item = lessonData[currentIndex];
            let correctAnswers = isTurkishQuestion 
                ? (Array.isArray(item.question) ? item.question : [item.question]) 
                : [item.answer];

            const baseCorrectAnswers = correctAnswers.map(a => extractBaseAnswer(a)[0]);
            const normalizedCorrectAnswers = baseCorrectAnswers.map(a => normalizeText(a));
            const latinAnswers = baseCorrectAnswers.map(a => normalizeText(cyrillicToLatinText(a)));
            const allCorrectAnswers = [...new Set([...normalizedCorrectAnswers, ...latinAnswers])];
            const inputNormalized = normalizeText(inputValue);

            const questionText = isTurkishQuestion ? item.answer : (Array.isArray(item.question) ? item.question[0] : item.question);
            const parentheticalWords = extractParentheticalWords(questionText);
            const normalizedBaseAnswer = normalizeText(extractBaseAnswer(correctAnswers[0])[0]);
            const extendedCorrectAnswers = parentheticalWords.length > 0 
                ? generateCombinations(parentheticalWords.map(normalizeText), normalizedBaseAnswer) 
                : [normalizedBaseAnswer];

            const pronouns = ['ben', 'sen', 'o', 'biz', 'siz', 'onlar'];
            const inputWords = inputNormalized.split(/\s+/);
            const hasPronounPrefix = pronouns.includes(inputWords[0]);
            const inputWithoutPronoun = hasPronounPrefix ? inputWords.slice(1).join(' ') : inputNormalized;

            let isCorrect = false;
            if (isTurkishQuestion) {
                const answerOptions = allCorrectAnswers.flatMap(a => a.split(/\s*\/\s*/));
                const answerParts = answerOptions.map(opt => opt.split(/\s+/));
                isCorrect = answerOptions.some(option => 
                    normalizeText(option) === inputNormalized || 
                    isAnswerCloseEnough(inputNormalized, option) ||
                    normalizeText(option) === inputWithoutPronoun || 
                    isAnswerCloseEnough(inputWithoutPronoun, option) ||
                    answerParts.some(parts => parts.includes(inputNormalized))
                );
            } else {
                const answerParts = extendedCorrectAnswers.map(a => a.split(/\s+/));
                isCorrect = extendedCorrectAnswers.some(a => 
                    a === inputNormalized || 
                    isAnswerCloseEnough(inputNormalized, a) ||
                    a === inputWithoutPronoun || 
                    isAnswerCloseEnough(inputWithoutPronoun, a) ||
                    answerParts.some(parts => parts.includes(inputNormalized))
                );
            }

            if (!isReload) {
                answers[currentIndex] = inputValue;
                if (inputValue === '' && !wrongCount[currentIndex]) {
                    wrongCount[currentIndex] = 1;
                    if (isRepeatWrongEnabled && !priorityQueue.includes(currentIndex)) priorityQueue.push(currentIndex);
                    if (!missedQuestions.includes(currentIndex)) missedQuestions.push(currentIndex);
                } else if (isCorrect) {
                    if (!wrongCount[currentIndex]) score += 1;
                    delete wrongCount[currentIndex];
                    priorityQueue = priorityQueue.filter(i => i !== currentIndex);
                    missedQuestions = missedQuestions.filter(i => i !== currentIndex);
                    playSound('correct');
                } else {
                    wrongCount[currentIndex] = (wrongCount[currentIndex] || 0) + 1;
                    if (isRepeatWrongEnabled && !priorityQueue.includes(currentIndex)) priorityQueue.push(currentIndex);
                    if (!missedQuestions.includes(currentIndex)) missedQuestions.push(currentIndex);
                    playSound('incorrect');
                }
            }

            const fullCorrectAnswer = isTurkishQuestion 
                ? correctAnswers.map(a => `${a}${isLatinVisible ? ` - ${cyrillicToLatinText(a)}` : ''}`).join(' / ')
                : correctAnswers.map(a => `${a}`).join(' / ');

            const words = (questionText + ' ' + fullCorrectAnswer).split(/\s+/);
            const allPossessives = Object.values(possessivePronouns).flat().map(p => p.split(' ')[0]);
            const allShortPossessives = Object.values(shortPossessivePronouns).map(p => p.split(' ')[0]);
            const allDemonstratives = Object.values(demonstrativePronouns).flat().map(p => p.split(' ')[0]);
            const allPrepositions = prepositions.map(p => p[0].split(' ')[0]);
            const allQuestionParticles = Object.values(questionParticles).map(p => p.split(' ')[0]);

            const matchedWords = [];
            if (words.some(word => allPossessives.includes(word))) matchedWords.push(words.find(word => allPossessives.includes(word)));
            if (words.some(word => allShortPossessives.includes(word))) matchedWords.push(words.find(word => allShortPossessives.includes(word)));
            if (words.some(word => allDemonstratives.includes(word))) matchedWords.push(words.find(word => allDemonstratives.includes(word)));
            if (words.some(word => allPrepositions.includes(word))) matchedWords.push(words.find(word => allPrepositions.includes(word)));
            if (words.some(word => allQuestionParticles.includes(word))) matchedWords.push(words.find(word => allQuestionParticles.includes(word)));

            const resultDiv = document.getElementById('result');
            if (resultDiv) {
                if (isCorrect) {
                    resultDiv.innerHTML = `<span class="result-icon correct">‚úÖ</span> Doƒüru! Girdiƒüiniz cevap: ${inputValue}`;
                    if (matchedWords.length > 0) updateTableFeedback(true, matchedWords);
                    if (!isReload && !isAutoNextPaused && (isMissedMode ? missedQuestions.indexOf(currentIndex) < missedQuestions.length - 1 : currentIndex < lessonData.length - 1)) {
                        autoNextTimeout = setTimeout(() => {
                            if (!isAutoNextPaused) {
                                moveToNextQuestion();
                                renderContent();
                            }
                        }, 2000);
                    }
                } else {
                    const closestAnswer = allCorrectAnswers.reduce((prev, curr) => 
                        levenshteinDistance(inputNormalized, prev) < levenshteinDistance(inputNormalized, curr) ? prev : curr
                    );
                    resultDiv.innerHTML = `<span class="result-icon incorrect">‚ùå</span> Yanlƒ±≈ü! '${inputValue}' yerine '${correctAnswers[0]}' bekleniyor. Tam cevap: ${fullCorrectAnswer}`;
                    if (matchedWords.length > 0) updateTableFeedback(false, matchedWords);
                }
                resultDiv.className = isCorrect ? 'correct' : 'incorrect';
            }
            if (input) input.disabled = true;
            const editBtn = document.getElementById('editBtn');
            if (editBtn) editBtn.disabled = false;
            document.getElementById('score').innerText = `Puan: ${score}`;
            isResultShown = true;
        }

        function moveToNextQuestion() {
            questionCounter++;
            if (isMissedMode && missedQuestions.length > 0) {
                const currentMissedIdx = missedQuestions.indexOf(currentIndex);
                if (currentMissedIdx < missedQuestions.length - 1) {
                    currentIndex = missedQuestions[currentMissedIdx + 1];
                }
            } else if (isSearchMode && searchResults.length > 0) {
                searchIndex = (searchIndex + 1) % searchResults.length;
                currentIndex = searchResults[searchIndex];
            } else if (!isSearchMode && priorityQueue.length > 0) {
                const nextInQueue = priorityQueue[0];
                const wrongTimes = wrongCount[nextInQueue] || 0;
                const interval = wrongTimes === 1 ? 10 : wrongTimes === 2 ? 5 : 3;
                if (questionCounter >= interval) {
                    const tempIndex = currentIndex;
                    currentIndex = nextInQueue;
                    questionCounter = 0;
                    renderContent();
                    setTimeout(() => {
                        currentIndex = tempIndex;
                        moveToNextSequential();
                        renderContent();
                    }, 2000);
                    return;
                }
                moveToNextSequential();
            } else {
                moveToNextSequential();
            }
        }

        function moveToNextSequential() {
            if (currentIndex < lessonData.length - 1) {
                do {
                    currentIndex++;
                } while (blacklist.includes(currentIndex) && currentIndex < lessonData.length - 1);
                lastSequentialIndex = currentIndex;
            }
        }

        function enableEdit() {
            const input = document.getElementById('input-answer');
            if (input) {
                input.disabled = false;
                input.focus();
            }
            const resultDiv = document.getElementById('result');
            if (resultDiv) resultDiv.innerHTML = '';
            const editBtn = document.getElementById('editBtn');
            if (editBtn) editBtn.disabled = true;
            isAutoNextPaused = true;
            if (autoNextTimeout) clearTimeout(autoNextTimeout);
            isResultShown = false;
        }

        function editQuestion() {
            const item = lessonData[currentIndex];
            if (isTurkishQuestion) {
                const newAnswer = prompt("Cevabƒ± d√ºzenle:", item.answer);
                if (newAnswer !== null) {
                    item.answer = newAnswer;
                    alert("Kaydedildi!");
                    renderContent();
                }
            } else {
                const currentQuestions = Array.isArray(item.question) ? item.question : [item.question];
                const newQuestion = prompt("Soruyu d√ºzenle (birden fazla cevap i√ßin / ile ayƒ±rƒ±n):", currentQuestions.join(' / '));
                if (newQuestion !== null) {
                    item.question = newQuestion.includes('/') ? newQuestion.split(' / ') : newQuestion;
                    alert("Kaydedildi!");
                    renderContent();
                }
            }
        }

        function toggleBlacklist(index) {
            const idx = blacklist.indexOf(index);
            if (idx === -1) {
                blacklist.push(index);
                if (currentIndex === index && !isAutoNextPaused && currentIndex < lessonData.length - 1) {
                    autoNextTimeout = setTimeout(() => {
                        if (!isAutoNextPaused) {
                            moveToNextQuestion();
                            renderContent();
                        }
                    }, 2000);
                }
            } else {
                blacklist.splice(idx, 1);
            }
            renderContent();
            updateBlacklist();
        }

        function updateRecentQuestions() {
            if (!recentQuestions.includes(currentIndex)) {
                recentQuestions.push(currentIndex);
                if (recentQuestions.length > 5) recentQuestions.shift();
            }
            const recentList = document.getElementById('recent-list');
            if (!recentList) return;
            recentList.innerHTML = '';
            recentQuestions.slice().reverse().forEach(index => {
                const item = lessonData[index];
                const answer = answers[index];
                let symbol = '';
                let symbolClass = '';
                if (answer === '' || answer === null || answer === undefined) {
                    symbol = '‚àÖ';
                    symbolClass = 'unanswered';
                } else if (answer) {
                    const correctAnswers = isTurkishQuestion ? (Array.isArray(item.question) ? item.question : [item.question]) : [item.answer];
                    const normalizedCorrectAnswers = correctAnswers.map(a => normalizeText(a));
                    const latinAnswers = correctAnswers.map(a => normalizeText(cyrillicToLatinText(a)));
                    const allCorrectAnswers = [...normalizedCorrectAnswers, ...latinAnswers];
                    const questionText = isTurkishQuestion ? item.answer : (Array.isArray(item.question) ? item.question[0] : item.question);
                    const parentheticalWords = extractParentheticalWords(questionText);
                    const normalizedBaseAnswer = normalizeText(extractBaseAnswer(correctAnswers[0])[0]);
                    const extendedCorrectAnswers = parentheticalWords.length > 0 
                        ? generateCombinations(parentheticalWords.map(normalizeText), normalizedBaseAnswer) 
                        : [normalizedBaseAnswer];
                    const isCorrect = isTurkishQuestion
                        ? allCorrectAnswers.some(a => a === normalizeText(answer) || isAnswerCloseEnough(normalizeText(answer), a))
                        : extendedCorrectAnswers.some(a => a === normalizeText(answer));
                    symbol = isCorrect ? '‚úÖ' : '‚ùå';
                    symbolClass = isCorrect ? 'correct' : 'incorrect';
                }
                const div = document.createElement('div');
                div.className = 'recent-question';
                div.innerHTML = `<span class="result-icon ${symbolClass}">${symbol}</span> ${index + 1}. ${isTurkishQuestion ? item.answer : cleanTextForDisplay((Array.isArray(item.question) ? item.question[0] : item.question))} (${answer || 'Cevap yok'})`;
                div.onclick = () => {
                    if (lastIndexBeforeJump === -1) lastIndexBeforeJump = currentIndex;
                    currentIndex = index;
                    renderContent();
                };
                recentList.appendChild(div);
            });
        }

        function updateSearchResults() {
            const searchInput = document.getElementById('search-input');
            if (!searchInput) return;
            const searchValue = searchInput.value.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            const searchList = document.getElementById('search-list');
            if (!searchList) return;
            searchList.innerHTML = '';
            searchResults = [];

            lessonData.forEach((item, index) => {
                const questions = Array.isArray(item.question) ? item.question : [item.question];
                const answer = normalizeText(item.answer);
                const questionMatch = questions.some(q => normalizeText(q).includes(searchValue));
                if ((questionMatch || answer.includes(searchValue)) && !blacklist.includes(index)) {
                    searchResults.push(index);
                    const div = document.createElement('div');
                    div.className = 'search-result';
                    const displayText = isTurkishQuestion 
                        ? `${item.answer} / ${questions.join(' / ')}` 
                        : `${cleanTextForDisplay(questions.join(' / '))} / ${item.answer}`;
                    div.innerText = `${index + 1}. ${displayText}`;
                    div.onclick = () => {
                        if (lastIndexBeforeJump === -1) lastIndexBeforeJump = currentIndex;
                        currentIndex = index;
                        if (isSearchMode) searchIndex = searchResults.indexOf(index);
                        renderContent();
                    };
                    searchList.appendChild(div);
                }
            });
        }

        function updateBlacklist() {
            const blacklistList = document.getElementById('blacklist-list');
            if (!blacklistList) return;
            blacklistList.innerHTML = '';
            blacklist.forEach(index => {
                const item = lessonData[index];
                const div = document.createElement('div');
                div.className = 'blacklist-item';
                div.innerHTML = `<input type="checkbox" class="blacklist-toggle" checked onclick="toggleBlacklist(${index})"> ${index + 1}. ${isTurkishQuestion ? item.answer : cleanTextForDisplay((Array.isArray(item.question) ? item.question[0] : item.question))}`;
                blacklistList.appendChild(div);
            });
        }

        function updateMissedQuestions() {
            const missedList = document.getElementById('missed-list');
            if (!missedList) return;
            missedList.innerHTML = '';
            missedQuestions.forEach(index => {
                const item = lessonData[index];
                const div = document.createElement('div');
                div.className = 'missed-question';
                div.innerHTML = `${index + 1}. ${isTurkishQuestion ? item.answer : cleanTextForDisplay((Array.isArray(item.question) ? item.question[0] : item.question))}`;
                div.onclick = () => {
                    if (lastIndexBeforeJump === -1) lastIndexBeforeJump = currentIndex;
                    currentIndex = index;
                    renderContent();
                };
                missedList.appendChild(div);
            });
        }

        function updateJsonFilesList() {
            const jsonFilesDiv = document.getElementById('json-files');
            if (!jsonFilesDiv) return;
            jsonFilesDiv.innerHTML = '';
            Object.entries(jsonFiles).forEach(([name, file], idx) => {
                const div = document.createElement('div');
                div.className = 'json-file';
                div.innerHTML = `
                    <div>
                        <input type="checkbox" id="json-${idx}" ${file.selected ? 'checked' : ''} onchange="toggleJsonFile('${name}')">
                        <label for="json-${idx}">${name}</label>
                    </div>
                    <button class="btn btn-danger btn-sm delete-btn" onclick="deleteJsonFile('${name}')">Sil</button>
                `;
                jsonFilesDiv.appendChild(div);
            });
        }

        function toggleJsonFile(fileName) {
            jsonFiles[fileName].selected = !jsonFiles[fileName].selected;
            updateLessonData();
        }

        function deleteJsonFile(fileName) {
            delete jsonFiles[fileName];
            updateLessonData();
            updateJsonFilesList();
        }

        document.getElementById('toggleOrderBtn').addEventListener('click', () => {
            isRandomOrder = !isRandomOrder;
            document.getElementById('toggleOrderBtn').innerText = `Sƒ±ralƒ± Mod (≈ûu an: ${isRandomOrder ? 'Rastgele' : 'Sƒ±ralƒ±'})`;
            if (lessonData.length > 0) {
                if (isRandomOrder) {
                    do {
                        currentIndex = Math.floor(Math.random() * lessonData.length);
                    } while (blacklist.includes(currentIndex));
                } else {
                    currentIndex = 0;
                }
                renderContent();
            }
        });

        document.getElementById('toggleLangBtn').addEventListener('click', () => {
            isTurkishQuestion = !isTurkishQuestion;
            document.getElementById('toggleLangBtn').innerText = isTurkishQuestion ? 'Bulgarca Sorulara Ge√ß' : 'T√ºrk√ße Sorulara Ge√ß';
            answers = Array(lessonData.length).fill(null);
            renderContent();
        });

        document.getElementById('toggleSpeechBtn').addEventListener('click', () => {
            isSpeechEnabled = !isSpeechEnabled;
            document.getElementById('toggleSpeechBtn').innerText = `Sesli Okuma (${isSpeechEnabled ? 'A√ßƒ±k' : 'Kapalƒ±'})`;
            if (isSpeechEnabled && lessonData.length > 0) {
                const item = lessonData[currentIndex];
                const question = isTurkishQuestion ? item.answer : (Array.isArray(item.question) ? item.question[0] : item.question);
                speakText(question);
            }
        });

        document.getElementById('toggleSoundBtn').addEventListener('click', () => {
            isSoundEnabled = !isSoundEnabled;
            document.getElementById('toggleSoundBtn').innerText = `Ses Efektleri (${isSoundEnabled ? 'A√ßƒ±k' : 'Kapalƒ±'})`;
        });

        document.getElementById('reviewMissedBtn').addEventListener('click', () => {
            if (isMissedMode) {
                isMissedMode = false;
                currentIndex = lastSequentialIndex;
            } else if (missedQuestions.length > 0) {
                isMissedMode = true;
                currentIndex = missedQuestions[0];
            }
            renderContent();
        });

        document.getElementById('question-slider').addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            if (isMissedMode) {
                currentIndex = missedQuestions[value];
            } else if (isSearchMode) {
                searchIndex = value;
                currentIndex = searchResults[searchIndex];
            } else {
                currentIndex = value;
                while (blacklist.includes(currentIndex) && currentIndex < lessonData.length - 1) {
                    currentIndex++;
                }
            }
            renderContent();
        });

        document.getElementById('toggleThemeBtn').addEventListener('click', () => {
            document.body.classList.toggle('dark-theme');
            document.getElementById('toggleThemeBtn').innerText = document.body.classList.contains('dark-theme') ? 'A√ßƒ±k Tema' : 'Koyu Tema';
        });

        document.getElementById('toggleRepeatWrongBtn').addEventListener('click', () => {
            isRepeatWrongEnabled = !isRepeatWrongEnabled;
            document.getElementById('toggleRepeatWrongBtn').innerText = `Yanlƒ±≈ülarƒ± Tekrarla (${isRepeatWrongEnabled ? 'A√ßƒ±k' : 'Kapalƒ±'})`;
            if (!isRepeatWrongEnabled) {
                priorityQueue = [];
            }
        });

        document.getElementById('saveBtn').addEventListener('click', () => {
            saveState();
        });

        document.getElementById('loadStateBtn').addEventListener('click', () => {
            loadSavedState();
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            resetState();
        });

        document.getElementById('saveToGitHubBtn').addEventListener('click', () => {
            saveToGitHub();
        });

        document.getElementById('search-input').addEventListener('input', () => {
            updateSearchResults();
            if (isSearchMode && searchResults.length > 0) {
                currentIndex = searchResults[0];
                searchIndex = 0;
                renderContent();
            }
        });

        document.getElementById('focus-questions').addEventListener('change', (e) => {
            isSearchMode = e.target.checked;
            if (isSearchMode && searchResults.length > 0) {
                currentIndex = searchResults[0];
                searchIndex = 0;
            } else if (!isSearchMode) {
                currentIndex = lastSequentialIndex;
            }
            renderContent();
        });

        document.getElementById('autoNextToggle').addEventListener('change', (e) => {
            isAutoNextPaused = !e.target.checked;
        });

        document.getElementById('loadFromUrlBtn').addEventListener('click', () => {
            const fileUrl = document.getElementById('fileUrl').value.trim();
            if (fileUrl) {
                loadOnlineLesson(fileUrl);
                const modal = bootstrap.Modal.getInstance(document.getElementById('loadJsonModal'));
                modal.hide();
            } else {
                alert('L√ºtfen bir GitHub Raw URL‚Äôsi girin!');
            }
        });

        document.getElementById('loadFromLocalBtn').addEventListener('click', () => {
            const fileInput = document.getElementById('localJsonFile');
            const file = fileInput.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const newData = JSON.parse(event.target.result);
                        jsonFiles[file.name] = { data: newData, selected: true };
                        updateLessonData();
                        updateJsonFilesList();
                        score = 0;
                        document.getElementById('score').innerText = `Puan: 0`;
                        const modal = bootstrap.Modal.getInstance(document.getElementById('loadJsonModal'));
                        modal.hide();
                    } catch (error) {
                        alert('Ge√ßersiz JSON formatƒ±: ' + error.message);
                    }
                };
                reader.readAsText(file);
            } else {
                alert('L√ºtfen bir JSON dosyasƒ± se√ßin!');
            }
        });

        document.getElementById('exportJsonBtn').addEventListener('click', () => {
            const jsonStr = JSON.stringify(lessonData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'bulgarca_ders_notlari.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        document.addEventListener('keydown', (event) => {
    const activeElement = document.activeElement;
    const isInputActive = activeElement.id === 'input-answer' || activeElement.id === 'search-input';

    // Saƒü ve sol oklar sadece metin kutusu aktif deƒüilken √ßalƒ±≈üsƒ±n
    if (!isInputActive) {
        if (event.key === 'ArrowLeft') {
            const prevBtn = document.getElementById('prevBtn');
            if (prevBtn && !prevBtn.disabled) prevBtn.click();
        } else if (event.key === 'ArrowRight') {
            const nextBtn = document.getElementById('nextBtn');
            if (nextBtn && !nextBtn.disabled) nextBtn.click();
        }
        // Space tu≈üu ile cevap d√ºzenlemeyi aktifle≈ütir
        else if (event.key === ' ' || event.key === 'Spacebar') {
            event.preventDefault(); // Sayfanƒ±n kaymasƒ±nƒ± √∂nler
            const editBtn = document.getElementById('editBtn');
            if (editBtn && !editBtn.disabled) {
                enableEdit();
            }
        }
    }

    // Yukarƒ± ve a≈üaƒüƒ± oklar her zaman sorularƒ± ileri/geri g√∂t√ºrs√ºn
    if (event.key === 'ArrowUp') {
        const prevBtn = document.getElementById('prevBtn');
        if (prevBtn && !prevBtn.disabled) prevBtn.click();
    } else if (event.key === 'ArrowDown') {
        const nextBtn = document.getElementById('nextBtn');
        if (nextBtn && !nextBtn.disabled) nextBtn.click();
    }

    if (event.key === 'Enter' && isResultShown) {
        event.preventDefault();
        if (autoNextTimeout) {
            clearTimeout(autoNextTimeout);
            autoNextTimeout = null;
        }
        moveToNextQuestion();
        renderContent();
    }

    if (event.key === 'Escape' && lastIndexBeforeJump !== -1) {
        currentIndex = lastIndexBeforeJump;
        lastIndexBeforeJump = -1;
        renderContent();
    }
});

        // Sayfa y√ºklendiƒüinde yerel depodan durumu kontrol et
        window.addEventListener('load', () => {
            const savedState = localStorage.getItem('bulgarcaAppState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    applyState(state);
                } catch (error) {
                    console.error('Yerel durum y√ºklenemedi: ', error);
                    resetState();
                }
            } else {
                loadAllLessons();
            }
        });

        // Otomatik ilerleme i√ßin kullanƒ±cƒ± etkinliƒüini izle
        document.addEventListener('mousemove', () => {
            isAutoNextPaused = true;
            if (autoNextTimeout) {
                clearTimeout(autoNextTimeout);
                autoNextTimeout = null;
            }
        });

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && lastIndexBeforeJump !== -1) {
                currentIndex = lastIndexBeforeJump;
                lastIndexBeforeJump = -1;
                renderContent();
            }
        });
    </script>
</body>
</html>